# 查询示例

## 示例概览

本文档提供详细的查询示例，帮助用户了解系统支持的各种查询类型和使用方法。

## 题目相关查询

### 1. 题目难度查询

#### 查询方式
**问题格式**: "题目 '{题目名称}' 的难度"

#### 示例查询
```
输入: "题目'两数之和'的难度"
```

#### 系统处理过程
```
🎯 意图识别: get_problem_difficulty
📝 提取参数: problem = "两数之和"
🔍 生成查询:
```
```cypher
MATCH (p:Problem) 
WHERE toLower(p.name) CONTAINS toLower($problem) 
RETURN p.name AS name, p.rating AS rating 
LIMIT 10
```

#### 预期结果
```
题目：两数之和 — 难度：1200
题目：Two Sum — 难度：1200
```

#### 更多示例
- "题目'最长公共子序列'的难度"
- "problem 'Knapsack' 的 rating"
- "问题'快速排序'的难度等级"

### 2. 题目详细信息查询

#### 查询方式
**问题格式**: "题目 '{题目名称}' 的信息"

#### 示例查询
```
输入: "题目'最长公共子序列'的信息"
```

#### 系统处理过程
```
🎯 意图识别: get_problem_info
📝 提取参数: problem = "最长公共子序列"
🔍 生成查询:
```
```cypher
MATCH (p:Problem) 
WHERE toLower(p.name) CONTAINS toLower($problem) 
OPTIONAL MATCH (p)-[:HAS_TAG]->(t:Tag) 
OPTIONAL MATCH (p)-[:HAS_SOLUTION]->(s:Solution) 
RETURN p.name AS name, p.rating AS rating, 
       collect(distinct t.name) AS tags, 
       collect(distinct s.id) AS solutions 
LIMIT 5
```

#### 预期结果
```
题目：最长公共子序列
难度：1400
标签：动态规划, 字符串
题解IDs：sol_001, sol_002, sol_003
```

## 标签与算法查询

### 3. 按标签查询题目

#### 查询方式
**问题格式**: "有哪些关于 {标签名} 的题目"

#### 示例查询
```
输入: "有哪些关于动态规划的题目"
```

#### 系统处理过程
```
🎯 意图识别: list_problems_by_tag
📝 提取参数: tag = "动态规划"
🔍 生成查询:
```
```cypher
MATCH (p:Problem)-[:HAS_TAG]->(t:Tag) 
WHERE toLower(t.name)=toLower($tag) 
RETURN p.name AS name, p.rating AS rating 
LIMIT 100
```

#### 预期结果
```
匹配题目：
- 最长公共子序列（难度：1400）
- 背包问题（难度：1500）
- 斐波那契数列（难度：1000）
- 最大子数组和（难度：1300）
```

#### 更多示例
- "列出涉及贪心算法的问题"
- "给我所有图论相关的题目"
- "有哪些数学题目"

### 4. 算法相关题目查询

#### 查询方式
**问题格式**: "使用 {算法名} 算法的题目"

#### 示例查询
```
输入: "使用Dijkstra算法的题目"
```

#### 系统处理过程
```
🎯 意图识别: find_problems_using_algorithm
📝 提取参数: algo = "Dijkstra"
🔍 生成查询:
```
```cypher
MATCH (p:Problem)-[:HAS_TAG]->(t:Tag) 
WHERE toLower(t.name) CONTAINS toLower($algo) 
RETURN p.name AS name, p.rating AS rating 
LIMIT 100
```

#### 预期结果
```
匹配题目：
- 最短路径问题（难度：1600）
- 网络流问题（难度：1800）
- 单源最短路（难度：1500）
```

#### 更多示例
- "涉及KMP算法的题目"
- "用到并查集的problem"
- "使用线段树的题目"

## 竞赛与选手查询

### 5. 竞赛冠军查询

#### 查询方式
**问题格式**: "谁是 {年份} 年冠军" 或 "谁是 {比赛名称} 冠军"

#### 示例查询
```
输入: "谁是2020年冠军"
```

#### 系统处理过程
```
🎯 意图识别: get_contest_winner
📝 提取参数: year_or_name = "2020"
🔍 生成查询:
```
```cypher
MATCH (tm:Team)-[r:PLACED]->(c:Contest) 
WHERE toLower(c.name) CONTAINS toLower($year_or_name) 
  AND r.rank IN ['1','1st','冠军'] 
RETURN tm.name AS team, r.rank AS rank, r.region AS region 
LIMIT 5
```

#### 预期结果
```
冠军/第一名：
Moscow SU: Red Team（地区：Europe，名次：1）
```

#### 更多示例
- "ICPC World Finals 第一名"
- "谁是2019年世界冠军"
- "亚洲区域赛冠军"

### 6. 作者题解查询

#### 查询方式
**问题格式**: "作者 {作者名} 的题解"

#### 示例查询
```
输入: "作者张三的题解"
```

#### 系统处理过程
```
🎯 意图识别: get_solutions_by_author
📝 提取参数: author = "张三"
🔍 生成查询:
```
```cypher
MATCH (pr:Person {name:$author})<-[:AUTHOR]-(s:Solution)<-[:HAS_SOLUTION]-(p:Problem) 
RETURN p.name AS problem, s.id AS sid, 
       substring(s.content,0,300) AS snippet 
LIMIT 50
```

#### 预期结果
```
该作者的题解：

两数之和 — solution id: sol_001
摘要: 使用哈希表存储访问过的元素，时间复杂度O(n)...

最长公共子序列 — solution id: sol_002  
摘要: 动态规划解法，状态转移方程为dp[i][j]...
```

#### 更多示例
- "由李四编写的solution"
- "作者王五的所有题解"
- "Tourist的题解"

## 高级查询技巧

### 查询格式建议

#### 1. 精确匹配
使用引号包围关键词以提高匹配精度：
```
推荐: "题目'两数之和'的难度"
避免: "题目两数之和的难度"
```

#### 2. 关键词选择
使用标准的算法和概念名称：
```
推荐: "动态规划"、"贪心算法"、"图论"
避免: "DP"、"贪心"、"图"
```

#### 3. 灵活表达
系统支持多种表达方式：
```
"有哪些关于动态规划的题目"
"列出涉及动态规划的问题"  
"给我动态规划相关的题目"
```

### 调试查询

#### 查看执行过程
系统会显示完整的查询处理过程：
1. **解析结果**: 意图类型和提取的参数
2. **Cypher查询**: 生成的数据库查询语句
3. **原始结果**: 数据库返回的结构化数据
4. **最终答案**: 格式化的自然语言答案

#### 无结果处理
如果查询无结果，可能的原因：
- 数据库中没有相关数据
- 关键词拼写错误
- 查询条件过于严格

建议尝试：
- 使用更通用的关键词
- 检查拼写是否正确
- 查看示例查询的格式

## 扩展查询

### 自定义查询
开发者可以通过修改配置文件添加新的查询类型：

1. **添加意图模式**:
```python
INTENT_PATTERNS = [
    # 新增查询类型
    ("new_query_type", r"查询模式正则表达式", ["参数名"]),
]
```

2. **定义查询模板**:
```python
CYPHER_TEMPLATES = {
    "new_query_type": "MATCH ... RETURN ... LIMIT ..."
}
```

3. **实现渲染逻辑**:
```python
def render_answer(intent, rows):
    if intent == "new_query_type":
        # 自定义渲染逻辑
        pass
```

### 查询优化建议
- 使用合适的LIMIT限制结果数量
- 在WHERE子句中使用索引字段
- 避免复杂的多跳关系查询
- 合理使用OPTIONAL MATCH处理可选关系