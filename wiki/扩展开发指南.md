# 扩展开发指南

## 开发环境配置

### 1. 开发工具准备
推荐使用以下开发工具：
- **IDE**: PyCharm, VS Code, 或其他支持Python的IDE
- **版本控制**: Git
- **数据库管理**: Neo4j Desktop Browser
- **API测试**: Postman (如果需要)

### 2. 代码规范
项目遵循以下代码规范：
- **PEP 8**: Python官方代码风格指南
- **类型注解**: 使用Type Hints提高代码可读性
- **文档字符串**: 使用docstring记录函数和类的功能
- **半角字符**: 代码中避免使用全角字符，特别是正则表达式

## 添加新查询类型

### 步骤概览
1. 定义意图模式
2. 创建查询模板
3. 实现答案渲染
4. 编写测试用例
5. 更新文档

### 1. 定义意图模式

在 `src/nl_to_cypher.py` 的 `INTENT_PATTERNS` 中添加新模式：

```python
INTENT_PATTERNS = [
    # 现有模式...
    
    # 新增查询类型 - 示例：查询题目提交统计
    ("get_problem_stats", 
     r"(?:题目|问题)\s*[\"']?([^\"']+)[\"']?\s*(?:的)?\s*(?:提交|统计|数据)", 
     ["problem"]),
]
```

#### 正则表达式设计原则
- **灵活匹配**: 支持多种表达方式
- **精确捕获**: 使用分组捕获关键参数
- **避免全角字符**: 使用半角括号和标点
- **大小写不敏感**: 使用`re.I`标志

#### 示例意图模式
```python
# 查询算法复杂度
("get_algorithm_complexity", 
 r"(?:算法|algorithm)\s*[\"']?([^\"']+)[\"']?\s*(?:的)?\s*(?:复杂度|complexity)", 
 ["algorithm"]),

# 查询比赛历史
("get_contest_history", 
 r"(?:比赛|竞赛|contest)\s*[\"']?([^\"']+)[\"']?\s*(?:的)?\s*(?:历史|history)", 
 ["contest"]),
```

### 2. 创建查询模板

在 `CYPHER_TEMPLATES` 中添加对应的Cypher查询：

```python
CYPHER_TEMPLATES = {
    # 现有模板...
    
    # 新增查询模板
    "get_problem_stats": """
        MATCH (p:Problem) 
        WHERE toLower(p.name) CONTAINS toLower($problem) 
        OPTIONAL MATCH (p)<-[s:SUBMITTED]-(u:User)
        RETURN p.name AS name, 
               count(s) AS submissions, 
               count(DISTINCT u) AS unique_users
        LIMIT 10
    """,
}
```

#### Cypher查询最佳实践
- **参数化查询**: 使用`$parameter`防止注入
- **性能优化**: 合理使用索引和LIMIT
- **错误处理**: 使用OPTIONAL MATCH处理可选关系
- **结果格式**: 使用AS子句重命名输出字段

### 3. 实现答案渲染

在 `src/answer_renderer.py` 中添加渲染逻辑：

```python
def render_answer(intent: str, rows: List[Dict]) -> str:
    if not rows:
        return "抱歉，未找到匹配的结果。"

    # 现有渲染逻辑...
    
    # 新增渲染逻辑
    if intent == "get_problem_stats":
        lines = []
        for r in rows:
            name = r.get('name', '未知题目')
            submissions = r.get('submissions', 0)
            users = r.get('unique_users', 0)
            lines.append(f"题目：{name}")
            lines.append(f"  总提交数：{submissions}")
            lines.append(f"  提交用户数：{users}")
            lines.append("")
        return "\n".join(lines)
    
    # fallback处理
    return str(rows)
```

#### 渲染设计原则
- **用户友好**: 使用自然语言描述结果
- **结构化**: 保持一致的格式风格
- **完整信息**: 展示所有重要的查询结果
- **错误处理**: 优雅处理空值和异常情况

### 4. 编写测试用例

在 `tests/` 目录下创建或扩展测试文件：

```python
# tests/test_new_features.py
import unittest
from src.nl_to_cypher import parse_intent, get_cypher_and_params
from src.answer_renderer import render_answer

class TestNewFeatures(unittest.TestCase):
    
    def test_problem_stats_intent(self):
        """测试题目统计查询意图识别"""
        question = "题目'两数之和'的提交数据"
        result = parse_intent(question)
        
        self.assertEqual(result['intent'], 'get_problem_stats')
        self.assertEqual(result['slots']['problem'], '两数之和')
    
    def test_problem_stats_cypher(self):
        """测试题目统计查询Cypher生成"""
        intent_data = {'intent': 'get_problem_stats', 'slots': {'problem': '两数之和'}}
        cypher, params = get_cypher_and_params(intent_data)
        
        self.assertIn('MATCH (p:Problem)', cypher)
        self.assertEqual(params['problem'], '两数之和')
    
    def test_problem_stats_render(self):
        """测试题目统计结果渲染"""
        rows = [{'name': '两数之和', 'submissions': 100, 'unique_users': 80}]
        result = render_answer('get_problem_stats', rows)
        
        self.assertIn('题目：两数之和', result)
        self.assertIn('总提交数：100', result)
```

## 模块扩展

### 1. 数据库助手扩展

为 `Neo4jHelper` 添加新功能：

```python
# src/neo4j_helper.py
class Neo4jHelper:
    # 现有方法...
    
    def run_batch_queries(self, queries: List[Tuple[str, Dict]]) -> List[List[Dict]]:
        """批量执行查询"""
        results = []
        with self.driver.session() as session:
            with session.begin_transaction() as tx:
                for cypher, params in queries:
                    result = tx.run(cypher, **params)
                    results.append([dict(record) for record in result])
        return results
    
    def get_schema_info(self) -> Dict:
        """获取数据库模式信息"""
        schema_query = """
        CALL db.schema.visualization()
        YIELD nodes, relationships
        RETURN nodes, relationships
        """
        with self.driver.session() as session:
            result = session.run(schema_query)
            return dict(result.single())
```

### 2. 缓存机制实现

添加查询结果缓存：

```python
# src/cache_helper.py
import time
from typing import Dict, Any, Optional

class QueryCache:
    def __init__(self, ttl: int = 300):  # 5分钟TTL
        self._cache: Dict[str, Dict[str, Any]] = {}
        self._ttl = ttl
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        if key in self._cache:
            entry = self._cache[key]
            if time.time() - entry['timestamp'] < self._ttl:
                return entry['value']
            else:
                del self._cache[key]
        return None
    
    def set(self, key: str, value: Any) -> None:
        """设置缓存值"""
        self._cache[key] = {
            'value': value,
            'timestamp': time.time()
        }
    
    def clear(self) -> None:
        """清空缓存"""
        self._cache.clear()

# 使用示例
cache = QueryCache()

def cached_query(cypher: str, params: Dict) -> List[Dict]:
    cache_key = f"{cypher}:{str(sorted(params.items()))}"
    
    # 尝试从缓存获取
    cached_result = cache.get(cache_key)
    if cached_result is not None:
        return cached_result
    
    # 执行查询
    result = neo4j_helper.run_query(cypher, params)
    
    # 存入缓存
    cache.set(cache_key, result)
    return result
```

### 3. 异步处理支持

实现异步查询处理：

```python
# src/async_helper.py
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Callable

class AsyncQueryProcessor:
    def __init__(self, max_workers: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_query(self, query_func: Callable, *args) -> Any:
        """异步执行查询"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(self.executor, query_func, *args)
    
    async def process_multiple_queries(self, queries: List[tuple]) -> List[Any]:
        """并行执行多个查询"""
        tasks = []
        for query_func, args in queries:
            task = self.process_query(query_func, *args)
            tasks.append(task)
        
        return await asyncio.gather(*tasks)
```

## 性能优化

### 1. 数据库索引优化

为常用查询字段创建索引：

```cypher
-- 为Problem节点的name字段创建索引
CREATE INDEX problem_name_index FOR (p:Problem) ON (p.name)

-- 为Tag节点的name字段创建索引  
CREATE INDEX tag_name_index FOR (t:Tag) ON (t.name)

-- 为Person节点的name字段创建索引
CREATE INDEX person_name_index FOR (p:Person) ON (p.name)

-- 创建复合索引
CREATE INDEX problem_rating_index FOR (p:Problem) ON (p.name, p.rating)
```

### 2. 查询优化策略

#### 查询重写
```python
# 优化前 - 可能导致全表扫描
"""
MATCH (p:Problem)
WHERE p.name CONTAINS $problem
RETURN p
"""

# 优化后 - 使用索引
"""
MATCH (p:Problem)
WHERE toLower(p.name) CONTAINS toLower($problem)
RETURN p
LIMIT 50
"""
```

#### 分页查询
```python
def get_problems_paginated(tag: str, page: int = 0, size: int = 20):
    cypher = """
    MATCH (p:Problem)-[:HAS_TAG]->(t:Tag)
    WHERE toLower(t.name) = toLower($tag)
    RETURN p.name AS name, p.rating AS rating
    ORDER BY p.rating DESC
    SKIP $skip LIMIT $limit
    """
    params = {
        'tag': tag,
        'skip': page * size,
        'limit': size
    }
    return neo4j_helper.run_query(cypher, params)
```

### 3. 监控和日志

实现性能监控：

```python
# src/performance_monitor.py
import time
import logging
from functools import wraps

def monitor_performance(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logging.info(f"{func.__name__} 执行时间: {execution_time:.2f}秒")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logging.error(f"{func.__name__} 执行失败: {e}, 耗时: {execution_time:.2f}秒")
            raise
    return wrapper

# 使用示例
@monitor_performance
def run_query(self, cypher: str, params: Dict = None):
    # 查询实现
    pass
```

## 部署和运维

### 1. Docker容器化

创建Dockerfile：

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY src/ ./src/
COPY wiki/ ./wiki/

EXPOSE 8501

CMD ["streamlit", "run", "src/app.py", "--server.address", "0.0.0.0"]
```

Docker Compose配置：

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8501:8501"
    environment:
      - NEO_URI=bolt://neo4j:7687
      - NEO_USER=neo4j
      - NEO_PWD=password
    depends_on:
      - neo4j

  neo4j:
    image: neo4j:5.9.0
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
    volumes:
      - neo4j_data:/data

volumes:
  neo4j_data:
```

### 2. 配置管理

创建配置管理模块：

```python
# src/config.py
import os
from typing import Dict, Any

class Config:
    def __init__(self):
        self.neo4j_uri = os.getenv('NEO_URI', 'bolt://localhost:7687')
        self.neo4j_user = os.getenv('NEO_USER', 'neo4j')
        self.neo4j_password = os.getenv('NEO_PWD', 'password')
        self.app_debug = os.getenv('APP_DEBUG', 'false').lower() == 'true'
        self.cache_ttl = int(os.getenv('CACHE_TTL', '300'))
        self.max_results = int(os.getenv('MAX_RESULTS', '100'))
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'neo4j_uri': self.neo4j_uri,
            'neo4j_user': self.neo4j_user,
            'app_debug': self.app_debug,
            'cache_ttl': self.cache_ttl,
            'max_results': self.max_results
        }

config = Config()
```

## 贡献指南

### 1. 代码贡献流程
1. Fork项目仓库
2. 创建功能分支 (`git checkout -b feature/新功能`)
3. 提交代码变更 (`git commit -am '添加新功能'`)
4. 推送到分支 (`git push origin feature/新功能`)
5. 创建Pull Request

### 2. 代码审查标准
- 代码符合PEP 8规范
- 包含完整的测试用例
- 更新相关文档
- 通过所有现有测试

### 3. 文档更新
新增功能时需要更新：
- README.md
- 相关Wiki文档
- 代码注释和docstring
- 示例和教程

这个扩展开发指南为开发者提供了完整的系统扩展方法，包括添加新查询类型、性能优化、部署运维等各个方面的详细说明。